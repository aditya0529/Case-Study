import boto3
import logging
import time
import traceback
from datetime import datetime, timedelta, timezone
from botocore.exceptions import ClientError

# Initialize AWS clients
iam_client = boto3.client("iam")
config_client = boto3.client("config")
securityhub_client = boto3.client("securityhub")

# Configure logging
logger = logging.getLogger()
logger.setLevel(logging.INFO)
if not logger.handlers:
    console_handler = logging.StreamHandler()
    formatter = logging.Formatter("%(asctime)s - %(levelname)s - %(message)s")
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)

def batch_import_findings_with_retry(findings_list):
    """Send findings to AWS Security Hub using batch_import_findings with retry logic."""
    max_retries = 5
    delay = 1  # Initial delay in seconds
    for attempt in range(max_retries):
        try:
            logger.debug(f"Attempting to send findings to Security Hub: {findings_list}")
            response = securityhub_client.batch_import_findings(Findings=findings_list)
            logger.info(f"Successfully sent batch of {len(findings_list)} findings to AWS Security Hub.")
            logger.debug(f"Response from AWS Security Hub: {response}")
            return True
        except ClientError as e:
            error_code = e.response.get("Error", {}).get("Code", "UnknownError")
            error_message = e.response.get("Error", {}).get("Message", "No error message available")
            status_code = e.response.get("ResponseMetadata", {}).get("HTTPStatusCode", "UnknownStatusCode")
            request_id = e.response.get("ResponseMetadata", {}).get("RequestId", "UnknownRequestId")

            if attempt == 0:
                logger.error(f"Initial failure: {error_code} - {error_message} - Status Code: {status_code} - Request ID: {request_id}")

            logger.error(f"ClientError on attempt {attempt + 1}: {error_code} - {error_message} - Status Code: {status_code}")

            if error_code in ["ThrottlingException", "TooManyRequestsException"]:
                logger.warning(f"Throttling error encountered. Retrying in {delay} seconds...")
                time.sleep(delay)
                delay *= 2  # Exponential backoff
            else:
                logger.error(f"Unrecoverable ClientError occurred: {e}")
                logger.error(f"Error Traceback: {traceback.format_exc()}")
                break  # Break out of the loop for unrecoverable errors
        except Exception as e:
            logger.error(f"Unexpected error on attempt {attempt + 1}: {e}")
            logger.error(f"Error Traceback: {traceback.format_exc()}")
            break  # Break out of the loop for unexpected errors
    logger.error("Max retries reached. Failed to send findings to AWS Security Hub.")
    return False  # Return False if all retries are exhausted

def lambda_handler(event, context):
    try:
        logger.info(f"Received event: {event}")
        # Set the threshold to 23 months (one month before 2-year key rotation)
        threshold_days = 23 * 30
        rotation_threshold_date = datetime.now(timezone.utc) - timedelta(days=threshold_days)

        non_compliant_keys = []  # List to store non-compliant access keys
        logger.info("Starting IAM access key compliance check...")

        # Use paginator to list all IAM users
        paginator = iam_client.get_paginator("list_users")
        logger.info("Retrieving IAM users...")

        for page in paginator.paginate():
            users = page["Users"]
            logger.info(f"Processing {len(users)} users")

            for user in users:
                logger.info(f"Processing user: {user['UserName']}")
                try:
                    # List access keys for each user
                    key_paginator = iam_client.get_paginator("list_access_keys")
                    for key_page in key_paginator.paginate(UserName=user["UserName"]):
                        access_keys = key_page["AccessKeyMetadata"]
                        logger.info(f"Found {len(access_keys)} access keys for user: {user['UserName']}")

                        for key in access_keys:
                            # Ensure timezone-aware datetime comparison
                            if key["CreateDate"] < rotation_threshold_date and key["Status"] == "Active":
                                key_age_days = (datetime.now(timezone.utc) - key["CreateDate"]).days
                                logger.warning(f"Access key {key['AccessKeyId']} is non-compliant (age: {key_age_days} days)")

                                # Construct Security Hub finding
                                finding = {
                                    "SchemaVersion": "2018-10-08",
                                    "Id": f"{user['UserName']}/{key['AccessKeyId']}",
                                    "ProductArn": f"arn:aws:securityhub:{context.invoked_function_arn.split(':')[3]}:aws:product/aws/securityhub",
                                    "GeneratorId": "iam-access-key-rotation-check",
                                    "AwsAccountId": context.invoked_function_arn.split(":")[4],
                                    "Types": ["Software and Configuration Checks/AWS Security Best Practices"],
                                    "CreatedAt": datetime.now(timezone.utc).isoformat(),
                                    "UpdatedAt": datetime.now(timezone.utc).isoformat(),
                                    "Severity": {"Label": "HIGH"},
                                    "Title": "IAM Access Key Rotation Best Practice Violation",
                                    "Description": f"Active IAM access key {key['AccessKeyId']} for user {user['UserName']} is older than 23 months (Key Age: {key_age_days} days).",
                                    "Resources": [
                                        {
                                            "Type": "AwsIamAccessKey",
                                            "Id": key["AccessKeyId"],
                                            "Partition": "aws",
                                            "Region": context.invoked_function_arn.split(":")[3]
                                        }
                                    ],
                                    "Compliance": {"Status": "FAILED"},
                                    "RecordState": "ACTIVE"
                                }

                                # Add the finding to the list
                                non_compliant_keys.append(finding)

                except ClientError as e:
                    logger.error(f"Error retrieving access keys for user {user['UserName']}: {e}")
                    logger.error(f"Error Traceback: {traceback.format_exc()}")

        # First, report compliance status to AWS Config
        compliance_type = "NON_COMPLIANT" if non_compliant_keys else "COMPLIANT"
        config_client.put_evaluations(
            Evaluations=[
                {
                    "ComplianceResourceType": "AWS::IAM::User",
                    "ComplianceResourceId": "IAMAccessKeyCheck",
                    "ComplianceType": compliance_type,
                    "OrderingTimestamp": datetime.now(timezone.utc)
                },
            ],
            ResultToken=event.get("resultToken", "NoTokenProvided")
        )
        logger.info(f"Compliance status reported to AWS Config: {compliance_type}")

        # Then, send findings to Security Hub with retry mechanism
        if non_compliant_keys:
            logger.info(f"Sending {len(non_compliant_keys)} findings to AWS Security Hub")
            batch_import_findings_with_retry(non_compliant_keys)

        logger.info("Process completed successfully")
        return {
            "statusCode": 200,
            "compliance_type": compliance_type
        }

    except Exception as e:
        logger.error(f"General error occurred: {e}")
        logger.error(f"Error Traceback: {traceback.format_exc()}")
        return {
            "statusCode": 500,
            "message": "An error occurred while processing the request."
        }
